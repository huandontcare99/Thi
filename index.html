<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Quiz Pro ‚Äì √în luy·ªán & Thi th·ª≠</title>

  <!-- Tailwind CDN (mobile-first) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Tinh ch·ªânh nh·ªè cho Tailwind (m√†u, radius)
    tailwind.config = {
      theme: {
        extend: {
          borderRadius: { 'xl2': '1rem' },
          boxShadow: { 'soft': '0 10px 25px -10px rgba(0,0,0,0.15)' }
        }
      }
    }
  </script>

  <!-- Style c·ª±c m·ªèng ƒë·ªÉ t·ªëi ∆∞u c·∫£m ·ª©ng -->
  <style>
    :root { color-scheme: light; }
    /* N√∫t ch·ªçn ƒë√°p √°n: tƒÉng v√πng ch·∫°m, tr√°nh miss click */
    .opt-item input[type="radio"]{ display:none; }
    .opt-item input[type="radio"] + label{
      display:block; padding:12px 14px; border-radius:14px; border:1px solid rgb(226 232 240);
    }
    .opt-item input[type="radio"]:checked + label{
      border-color: rgb(59 130 246);
      outline: 3px solid rgba(59,130,246,.15);
      background: white;
    }
    /* Tr·∫°ng th√°i ƒë√∫ng/sai trong luy·ªán t·∫≠p/thi */
    .is-correct { border-color: rgb(34 197 94) !important; background: #f0fdf4; }
    .is-wrong   { border-color: rgb(239 68 68) !important; background: #fef2f2; }
    /* Fix iOS input zoom */
    @media (max-width: 380px){
      select, input, button { font-size: 16px; }
    }
  </style>
</head>

<body class="bg-slate-50 text-slate-800 min-h-screen">
  <!-- HEADER: kh√¥ng che n·ªôi dung, sticky nh·∫π -->
  <header class="sticky top-0 z-40 backdrop-blur bg-white/85 border-b border-slate-200">
    <div class="max-w-4xl mx-auto px-3 py-2">
      <div class="flex items-center gap-2">
        <div class="flex items-center gap-2 min-w-0">
          <div class="w-9 h-9 rounded-xl2 bg-blue-600 text-white flex items-center justify-center font-bold shadow-soft">Q</div>
          <div class="truncate">
            <h1 class="text-base font-semibold leading-tight">Quiz Pro</h1>
            <p class="text-xs text-slate-500 leading-tight">√în luy·ªán & Thi th·ª≠ (Mobile-first)</p>
          </div>
        </div>

        <!-- Toggle m·ªü/ƒë√≥ng b·∫£ng ƒëi·ªÅu khi·ªÉn tr√™n mobile -->
        <button id="btnToggleToolbar"
          class="ml-auto inline-flex items-center gap-2 rounded-xl2 px-3 py-2 border border-slate-200 bg-white hover:bg-slate-50 active:scale-[.99]">
          <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16"/></svg>
          <span class="text-sm">B·∫£ng ƒëi·ªÅu khi·ªÉn</span>
        </button>
      </div>

      <!-- TOOLBAR: x·∫øp d·ªçc tr√™n mobile, 2 h√†ng tr√™n tablet, kh√¥ng ch·ªìng l·∫•n -->
      <div id="toolbar" class="mt-2 grid grid-cols-1 gap-2 md:grid-cols-2 lg:grid-cols-3">
        <div class="flex gap-2">
          <label class="text-sm text-slate-600 pt-2 min-w-[70px]">M√¥n</label>
          <select id="subjectSelect" class="flex-1 rounded-xl2 border border-slate-200 bg-white px-3 py-2">
            <option>ƒêang n·∫°p d·ªØ li·ªáu‚Ä¶</option>
          </select>
        </div>

        <div class="flex gap-2">
          <label class="text-sm text-slate-600 pt-2 min-w-[70px]">Ch·∫ø ƒë·ªô</label>
          <select id="modeSelect" class="flex-1 rounded-xl2 border border-slate-200 bg-white px-3 py-2">
            <option value="study">H·ªçc (hi·ªán ƒë√°p √°n)</option>
            <option value="practice">Luy·ªán t·∫≠p (ch·∫•m ngay)</option>
            <option value="exam">Thi th·ª≠ (ch·∫•m cu·ªëi, c√≥ gi·ªù)</option>
          </select>
        </div>

        <div class="flex gap-2">
          <label class="text-sm text-slate-600 pt-2 min-w-[70px]">S·ªë c√¢u</label>
          <select id="countSelect" class="flex-1 rounded-xl2 border border-slate-200 bg-white px-3 py-2">
            <option value="10">10</option>
            <option value="20" selected>20</option>
            <option value="30">30</option>
            <option value="all">T·∫•t c·∫£</option>
          </select>
        </div>

        <div class="flex gap-2">
          <label class="text-sm text-slate-600 pt-2 min-w-[70px]">S·∫Øp x·∫øp</label>
          <select id="orderSelect" class="flex-1 rounded-xl2 border border-slate-200 bg-white px-3 py-2">
            <option value="sequence">Theo th·ª© t·ª±</option>
            <option value="shuffle">Ng·∫´u nhi√™n</option>
          </select>
        </div>

        <div class="flex gap-2">
          <label class="text-sm text-slate-600 pt-2 min-w-[70px]">B·ªô l·ªçc</label>
          <select id="filterSelect" class="flex-1 rounded-xl2 border border-slate-200 bg-white px-3 py-2">
            <option value="all" selected>T·∫•t c·∫£</option>
            <option value="bookmarked">ƒê√£ ƒë√°nh d·∫•u</option>
            <option value="wrong">Sai g·∫ßn ƒë√¢y</option>
          </select>
        </div>

        <div class="flex gap-2">
          <label class="text-sm text-slate-600 pt-2 min-w-[70px]">T√¨m</label>
          <input id="searchInput" placeholder="T·ª´ kh√≥a c√¢u h·ªèi‚Ä¶" class="flex-1 rounded-xl2 border border-slate-200 bg-white px-3 py-2" />
        </div>

        <div class="md:col-span-2 lg:col-span-3 flex gap-2 mt-1">
          <button id="btnStart" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white rounded-xl2 px-4 py-3 font-semibold shadow-soft active:scale-[.99]">
            B·∫Øt ƒë·∫ßu
          </button>
          <button id="btnReset" class="px-4 py-3 rounded-xl2 border border-slate-200 bg-white hover:bg-slate-50 active:scale-[.99]">
            X√≥a k·∫øt qu·∫£
          </button>
        </div>
      </div>
    </div>
  </header>

  <main class="max-w-4xl mx-auto px-3 pb-24">
    <!-- Thanh ti·∫øn tr√¨nh -->
    <div class="mt-3">
      <div class="h-2 w-full bg-slate-200 rounded-full overflow-hidden">
        <div id="progressBar" class="h-2 bg-blue-600 transition-[width] duration-300" style="width:0%"></div>
      </div>
      <div class="mt-1 text-xs text-slate-500" id="progressText">0 / 0</div>
    </div>

    <!-- Khu c√¢u h·ªèi -->
    <section id="quizArea" class="mt-3 space-y-3">
      <!-- Th√¥ng ƒëi·ªáp -->
      <div id="emptyMsg" class="hidden bg-amber-50 border border-amber-200 text-amber-800 rounded-xl2 p-3 text-sm">
        Ch∆∞a c√≥ b√†i. H√£y ch·ªçn m√¥n, ch·∫ø ƒë·ªô v√† nh·∫•n <b>B·∫Øt ƒë·∫ßu</b>.
      </div>

      <!-- Th·∫ª c√¢u h·ªèi -->
      <article id="card" class="hidden rounded-2xl bg-white border border-slate-200 shadow-soft p-4">
        <div class="flex items-start gap-2">
          <div class="text-xs px-2 py-1 rounded bg-slate-100 text-slate-600" id="badgeSubject">M√¥n</div>
          <div class="text-xs px-2 py-1 rounded bg-slate-100 text-slate-600" id="badgeMode">Ch·∫ø ƒë·ªô</div>
          <div class="ml-auto text-xs text-slate-500" id="timerBox" hidden>‚è± <span id="timer">00:00</span></div>
        </div>

        <h2 id="qTitle" class="mt-2 text-base font-semibold"></h2>

        <div id="optList" class="mt-2 space-y-2"></div>

        <div id="explainBox" class="mt-3 hidden">
          <div class="text-sm font-semibold mb-1">Gi·∫£i th√≠ch</div>
          <div id="explain" class="text-sm text-slate-700"></div>
        </div>

        <div class="mt-4 flex flex-wrap gap-2">
          <button id="btnPrev" class="px-4 py-2 rounded-xl2 border border-slate-200 bg-white hover:bg-slate-50">‚Üê Tr∆∞·ªõc</button>
          <button id="btnNext" class="px-4 py-2 rounded-xl2 border border-slate-200 bg-white hover:bg-slate-50">Ti·∫øp ‚Üí</button>
          <button id="btnCheck" class="px-4 py-2 rounded-xl2 border border-slate-200 bg-white hover:bg-slate-50">Ch·∫•m c√¢u n√†y</button>
          <button id="btnReveal" class="px-4 py-2 rounded-xl2 border border-slate-200 bg-white hover:bg-slate-50">Hi·ªán ƒë√°p √°n</button>
          <button id="btnBookmark" class="ml-auto px-4 py-2 rounded-xl2 border border-slate-200 bg-white hover:bg-slate-50">üîñ ƒê√°nh d·∫•u</button>
          <button id="btnSubmit" class="px-4 py-2 rounded-xl2 bg-blue-600 text-white hover:bg-blue-700">N·ªôp b√†i</button>
        </div>
      </article>

      <!-- K·∫øt qu·∫£ -->
      <article id="resultCard" class="hidden rounded-2xl bg-white border border-slate-200 shadow-soft p-4">
        <h3 class="text-lg font-bold mb-1">K·∫øt qu·∫£</h3>
        <p id="scoreText" class="text-sm text-slate-700"></p>
        <div class="mt-3 flex flex-wrap gap-2">
          <button id="btnReviewWrong" class="px-4 py-2 rounded-xl2 border border-slate-200 bg-white hover:bg-slate-50">
            Luy·ªán l·∫°i c√¢u sai
          </button>
          <button id="btnRestart" class="px-4 py-2 rounded-xl2 bg-blue-600 text-white hover:bg-blue-700">
            L√†m l·∫°i
          </button>
        </div>
      </article>
    </section>

    <!-- Danh s√°ch c√¢u (m·ªü b·∫±ng n√∫t ·ªü ƒë√°y) -->
    <div id="sheet" class="fixed inset-x-0 bottom-0 z-30 hidden">
      <div class="mx-auto max-w-4xl rounded-t-2xl bg-white shadow-2xl border border-slate-200">
        <div class="p-3 flex items-center gap-2 border-b border-slate-200">
          <div class="font-semibold">Danh s√°ch c√¢u</div>
          <button id="sheetClose" class="ml-auto px-3 py-1 rounded-xl2 border border-slate-200 bg-white hover:bg-slate-50">ƒê√≥ng</button>
        </div>
        <div id="qGrid" class="p-3 grid grid-cols-10 gap-1 max-h-[40vh] overflow-auto"></div>
      </div>
    </div>

  </main>

  <!-- FAB m·ªü danh s√°ch c√¢u ‚Äì kh√¥ng che n·ªôi dung -->
  <button id="fab" class="fixed bottom-4 right-4 z-20 rounded-full bg-blue-600 text-white w-12 h-12 shadow-soft hover:bg-blue-700 active:scale-[.98]" title="Danh s√°ch c√¢u">
    #
  </button>

  <!-- N·∫°p data.js tr∆∞·ªõc app (ƒë·ªÉ l·∫•y window.quizData / RAW_* / JSON) -->
  <script src="data.js"></script>

  <!-- ·ª®ng d·ª•ng -->
  <script>
  (function(){
    "use strict";

    // ====== Utils ======
    const $ = sel => document.querySelector(sel);
    const $$ = sel => document.querySelectorAll(sel);
    const byId = id => document.getElementById(id);

    const normalize = (s) => (s ?? "")
      .toString()
      .replace(/\s+/g, ' ')
      .trim()
      .normalize('NFD').replace(/[\u0300-\u036f]/g,'') // b·ªè d·∫•u
      .replace(/[‚Äú‚Äù"']/g,'')
      .toLowerCase();

    const choiceLetters = ['A','B','C','D','E','F']; // ph√≤ng xa

    // Local storage keys
    const LS_BOOK = 'quizpro_bookmarks';
    const LS_WRONG = 'quizpro_wrong';

    const loadLS = (k, def) => {
      try { return JSON.parse(localStorage.getItem(k)) ?? def; } catch{ return def; }
    }
    const saveLS = (k, v) => localStorage.setItem(k, JSON.stringify(v));

    // ====== Parse legacy RAW text ch·∫Øc tay ======
    function parseLegacyText(raw){
      // T√°ch t·ª´ng block theo ‚ÄúC√¢u x:‚Äù cho b·ªÅn
      const blocks = [];
      const re = /(^|\n)C√¢u\s*\d+\s*:[\s\S]*?(?=(?:\n[-=]{3,}\s*\n)|(?:\n\s*C√¢u\s*\d+\s*:)|\s*$)/gi;
      let m; while((m = re.exec(raw))){ blocks.push(m[0]); }

      const questions = [];
      for(const b of blocks){
        // L·∫•y ph·∫ßn th√¢n
        const qMatch = /C√¢u\s*\d+\s*:\s*([\s\S]*?)\n\s*ƒê√°p √°n ƒë√∫ng:\s*([^\n]+)\s*\n/i.exec(b);
        if(!qMatch) continue;
        const qText = qMatch[1].trim();
        const correctText = qMatch[2].trim();

        // L·∫•y ph·∫ßn ƒë√°p √°n
        let optPart = /T·∫•t c·∫£ ƒë√°p √°n:\s*([\s\S]*)/i.exec(b)?.[1] ?? '';
        // Harvest c√°c d√≤ng A./B./C./D. (k·ªÉ c·∫£ c√≥ ‚úì l·∫´n kho·∫£ng tr·∫Øng lung tung)
        const opts = [];
        const lines = optPart.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
        for(const ln of lines){
          const m2 = /^([A-Z])\.\s*(.*)$/.exec(ln);
          if(!m2) continue;
          const letter = m2[1].toUpperCase();
          let text = m2[2].trim();
          const hasCheck = /‚úì/.test(text);
          text = text.replace(/^‚úì\s*/,'').replace(/\s*‚úì\s*$/,'').trim();
          opts.push({ letter, text, hasCheck });
        }

        if(opts.length === 0) continue;

        // X√°c ƒë·ªãnh ƒë√°p √°n ƒë√∫ng:
        let answerIndex = opts.findIndex(o=>o.hasCheck);
        if(answerIndex < 0){
          // So kh·ªõp theo ‚Äúƒê√°p √°n ƒë√∫ng‚Äù
          const normCorrect = normalize(correctText);
          answerIndex = opts.findIndex(o => normalize(o.text) === normCorrect);
          if(answerIndex < 0){
            // Th·ª≠ contains ƒë·ªÉ ch·ªãu sai kh√°c nh·∫π
            answerIndex = opts.findIndex(o => normalize(o.text).includes(normCorrect) || normCorrect.includes(normalize(o.text)));
          }
        }
        if(answerIndex < 0) answerIndex = 0; // fallback an to√†n

        questions.push({
          text: qText,
          options: opts.map(o=>o.text),
          answer: answerIndex,
          explain: '' // d·ªØ li·ªáu legacy kh√¥ng k√®m gi·∫£i th√≠ch chi ti·∫øt
        });
      }
      return questions;
    }

    // ====== N·∫°p subjects t·ª´ data.js (∆∞u ti√™n JSON, sau ƒë√≥ RAW) ======
    function loadSubjects(){
      const subjects = [];

      // C√ÅCH 1: JSON (n·∫øu c√≥)
      if(window.quizDataJSON?.subjects?.length){
        for(const s of window.quizDataJSON.subjects){
          subjects.push({
            id: s.id || normalize(s.name).replace(/\W+/g,'-'),
            name: s.name,
            questions: s.questions.map(q=>({
              text: q.text, options: q.options, answer: q.answer, explain: q.explain || ''
            }))
          });
        }
        return subjects;
      }

      // C√ÅCH 2a: API getAll() c·ªßa b·∫°n
      if(window.quizData?.getAll){
        try{
          const arr = window.quizData.getAll();
          for(const it of arr){
            subjects.push({
              id: normalize(it.subject).replace(/\W+/g,'-'),
              name: it.subject,
              questions: parseLegacyText(String(it.text || ''))
            });
          }
          return subjects;
        }catch(e){
          console.warn('L·ªói ƒë·ªçc quizData.getAll()', e);
        }
      }

      // C√ÅCH 2b: Qu√©t bi·∫øn RAW_* n·∫øu c√≥
      const globalKeys = Object.keys(window);
      const rawKeys = globalKeys.filter(k => /^RAW_/.test(k));
      for(const k of rawKeys){
        const name = k.replace(/^RAW_/,'');
        subjects.push({
          id: normalize(name).replace(/\W+/g,'-'),
          name,
          questions: parseLegacyText(String(window[k]||''))
        });
      }
      return subjects;
    }

    // ====== State ======
    const state = {
      subjects: [],
      subjectIdx: 0,
      mode: 'study', // study | practice | exam
      order: 'sequence',
      filter: 'all',
      search: '',
      pool: [],           // danh s√°ch c√¢u ƒë√£ l·ªçc/s·∫Øp x·∫øp
      cur: 0,
      answers: {},        // idx -> ch·ªçn c·ªßa user
      checked: {},        // idx -> true/false ƒë√£ ch·∫•m
      bookmarks: loadLS(LS_BOOK, {}),
      wrongBank: loadLS(LS_WRONG, []), // l∆∞u id c√¢u sai g·∫ßn ƒë√¢y (t·ªëi ƒëa 200)
      timer: null,
      seconds: 0,
    };

    // ====== UI refs ======
    const subjectSelect = byId('subjectSelect');
    const modeSelect    = byId('modeSelect');
    const countSelect   = byId('countSelect');
    const orderSelect   = byId('orderSelect');
    const filterSelect  = byId('filterSelect');
    const searchInput   = byId('searchInput');
    const btnStart      = byId('btnStart');
    const btnReset      = byId('btnReset');
    const btnToggleToolbar = byId('btnToggleToolbar');

    const emptyMsg   = byId('emptyMsg');
    const card       = byId('card');
    const badgeSubject = byId('badgeSubject');
    const badgeMode  = byId('badgeMode');
    const timerBox   = byId('timerBox');
    const timerLabel = byId('timer');

    const qTitle     = byId('qTitle');
    const optList    = byId('optList');
    const explainBox = byId('explainBox');
    const explain    = byId('explain');

    const btnPrev    = byId('btnPrev');
    const btnNext    = byId('btnNext');
    const btnCheck   = byId('btnCheck');
    const btnReveal  = byId('btnReveal');
    const btnBookmark= byId('btnBookmark');
    const btnSubmit  = byId('btnSubmit');

    const progressBar  = byId('progressBar');
    const progressText = byId('progressText');

    const resultCard = byId('resultCard');
    const scoreText  = byId('scoreText');
    const btnReviewWrong = byId('btnReviewWrong');
    const btnRestart = byId('btnRestart');

    const sheet     = byId('sheet');
    const qGrid     = byId('qGrid');
    const sheetClose= byId('sheetClose');
    const fab       = byId('fab');
    const toolbar   = byId('toolbar');

    // ====== Init ======
    function init(){
      state.subjects = loadSubjects();
      renderSubjectOptions();

      // S·ª± ki·ªán
      btnStart.onclick  = start;
      btnReset.onclick  = resetAll;
      btnPrev.onclick   = prevQ;
      btnNext.onclick   = nextQ;
      btnCheck.onclick  = checkThis;
      btnReveal.onclick = revealThis;
      btnSubmit.onclick = submitAll;
      btnBookmark.onclick = toggleBookmark;

      subjectSelect.onchange = ()=>{ state.subjectIdx = subjectSelect.selectedIndex; };
      modeSelect.onchange    = ()=>{ state.mode = modeSelect.value; };
      orderSelect.onchange   = ()=>{ state.order = orderSelect.value; };
      filterSelect.onchange  = ()=>{ state.filter = filterSelect.value; };
      countSelect.onchange   = ()=>{};
      searchInput.oninput    = ()=>{ state.search = searchInput.value; };

      fab.onclick = ()=> sheet.classList.toggle('hidden');
      sheetClose.onclick = ()=> sheet.classList.add('hidden');
      btnToggleToolbar.onclick = ()=> toolbar.classList.toggle('hidden');

      // M·∫∑c ƒë·ªãnh hi·ªÉn th·ªã th√¥ng ƒëi·ªáp
      showEmpty();
    }

    function renderSubjectOptions(){
      subjectSelect.innerHTML = '';
      if(state.subjects.length === 0){
        subjectSelect.innerHTML = '<option>Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu</option>';
        return;
      }
      state.subjects.forEach((s, i)=>{
        const opt = document.createElement('option');
        opt.value = i; opt.textContent = s.name || ('M√¥n ' + (i+1));
        subjectSelect.appendChild(opt);
      });
      state.subjectIdx = 0;
    }

    // ====== L·ªçc / S·∫Øp x·∫øp / T·∫°o pool ======
    function makePool(){
      const subj = state.subjects[state.subjectIdx];
      if(!subj) return [];

      let arr = subj.questions.map((q, idx)=>({
        ...q,
        _id: idx // id n·ªôi b·ªô ƒë·ªÉ nh·ªõ sai/ƒë√∫ng/bookmark
      }));

      // T√¨m ki·∫øm theo t·ª´ kh√≥a
      if(state.search.trim()){
        const key = normalize(state.search);
        arr = arr.filter(q => normalize(q.text).includes(key) ||
                              q.options.some(o=> normalize(o).includes(key)));
      }

      // B·ªô l·ªçc
      if(state.filter === 'bookmarked'){
        arr = arr.filter(q => !!state.bookmarks[`${state.subjectIdx}:${q._id}`]);
      } else if(state.filter === 'wrong'){
        const set = new Set(state.wrongBank.map(x=>`${x.s}:${x.q}`));
        arr = arr.filter(q => set.has(`${state.subjectIdx}:${q._id}`));
      }

      // S·ªë c√¢u
      let need = countSelect.value === 'all' ? arr.length : Math.min(+countSelect.value || 20, arr.length);

      // S·∫Øp x·∫øp
      if(state.order === 'shuffle'){
        arr = arr.sort(()=>Math.random()-.5);
      }

      return arr.slice(0, need);
    }

    // ====== Start / Restart ======
    function start(){
      // Reset timer/answers
      clearTimer();
      state.answers = {};
      state.checked = {};
      resultCard.classList.add('hidden');

      state.pool = makePool();
      state.cur = 0;

      if(state.pool.length === 0){
        showEmpty();
        return;
      }

      // Timer cho thi th·ª≠
      if(state.mode === 'exam'){
        startTimer(); // ƒë∆°n gi·∫£n: ƒë·∫øm l√™n t·ª´ 0 (c√≥ th·ªÉ ƒë·ªïi th√†nh ƒë·∫øm ng∆∞·ª£c)
      }

      badgeSubject.textContent = state.subjects[state.subjectIdx]?.name || 'M√¥n';
      badgeMode.textContent = (
        state.mode==='study' ? 'H·ªçc' :
        state.mode==='practice' ? 'Luy·ªán t·∫≠p' : 'Thi th·ª≠'
      );

      sheet.classList.add('hidden');
      renderQuestion();
      updateProgress();
      buildGrid();
    }

    function resetAll(){
      localStorage.removeItem(LS_BOOK);
      localStorage.removeItem(LS_WRONG);
      state.bookmarks = {};
      state.wrongBank = [];
      alert('ƒê√£ x√≥a ƒë√°nh d·∫•u & l·ªãch s·ª≠ sai g·∫ßn ƒë√¢y.');
    }

    // ====== Render c√¢u h·ªèi ======
    function renderQuestion(){
      const q = state.pool[state.cur];
      if(!q){
        showEmpty(); return;
      }
      emptyMsg.classList.add('hidden');
      card.classList.remove('hidden');

      qTitle.textContent = `C√¢u ${state.cur+1}: ${q.text}`;
      optList.innerHTML = '';
      explainBox.classList.add('hidden');
      explain.textContent = q.explain || '';

      q.options.forEach((o, i)=>{
        const id = `opt-${state.cur}-${i}`;
        const wrap = document.createElement('div');
        wrap.className = 'opt-item';

        const input = document.createElement('input');
        input.type = 'radio';
        input.name = `q-${state.cur}`;
        input.id = id;
        input.value = i;
        input.checked = (state.answers[state.cur] === i);
        input.onchange = ()=> {
          state.answers[state.cur] = i;
          if(state.mode === 'practice'){
            // ch·∫•m ngay
            markOptions();
          }
        };

        const lab = document.createElement('label');
        lab.setAttribute('for', id);
        lab.className = 'hover:bg-slate-50';
        lab.innerHTML = `<div class="flex gap-2">
          <div class="text-slate-500">${choiceLetters[i] || ''}.</div>
          <div class="flex-1">${o}</div>
        </div>`;

        wrap.appendChild(input);
        wrap.appendChild(lab);
        optList.appendChild(wrap);
      });

      // N√∫t hi·ªÉn th·ªã
      btnCheck.classList.toggle('hidden', state.mode!=='practice');
      btnReveal.classList.toggle('hidden', state.mode!=='study');
      btnSubmit.classList.toggle('hidden', state.mode!=='exam');

      // Bookmark state
      const key = `${state.subjectIdx}:${q._id}`;
      btnBookmark.textContent = state.bookmarks[key] ? 'üîñ ƒê√£ ƒë√°nh d·∫•u' : 'üîñ ƒê√°nh d·∫•u';

      // Timer hi·ªÉn th·ªã
      timerBox.hidden = (state.mode!=='exam');

      // N·∫øu study th√¨ highlight ƒë√°p √°n ƒë√∫ng nh·∫π khi b·∫•m "Hi·ªán ƒë√°p √°n"
      // (m·∫∑c ƒë·ªãnh kh√¥ng highlight ƒë·ªÉ b·∫°n t·ª± suy nghƒ© tr∆∞·ªõc)
      clearMarks();
    }

    function clearMarks(){
      $$('#optList label').forEach(el=>{
        el.classList.remove('is-correct','is-wrong');
      });
    }

    function markOptions(){
      // ƒë√°nh d·∫•u ƒë√∫ng/sai cho Luy·ªán t·∫≠p ho·∫∑c sau khi Check
      const q = state.pool[state.cur];
      const pick = state.answers[state.cur];
      clearMarks();
      const labels = $$('#optList label');
      if(labels[q.answer]) labels[q.answer].classList.add('is-correct');
      if(pick != null && pick !== q.answer && labels[pick]) labels[pick].classList.add('is-wrong');
      state.checked[state.cur] = true;
    }

    function revealThis(){
      // H·ªçc: highlight ƒë√°p √°n + b·∫≠t gi·∫£i th√≠ch n·∫øu c√≥
      const q = state.pool[state.cur];
      const labels = $$('#optList label');
      clearMarks();
      if(labels[q.answer]) labels[q.answer].classList.add('is-correct');
      if(q.explain) explainBox.classList.remove('hidden');
    }

    function checkThis(){
      if(state.mode!=='practice') return;
      markOptions();
    }

    function toggleBookmark(){
      const q = state.pool[state.cur];
      const key = `${state.subjectIdx}:${q._id}`;
      state.bookmarks[key] = !state.bookmarks[key];
      saveLS(LS_BOOK, state.bookmarks);
      btnBookmark.textContent = state.bookmarks[key] ? 'üîñ ƒê√£ ƒë√°nh d·∫•u' : 'üîñ ƒê√°nh d·∫•u';
    }

    function prevQ(){ if(state.cur>0){ state.cur--; renderQuestion(); updateProgress(); } }
    function nextQ(){ if(state.cur<state.pool.length-1){ state.cur++; renderQuestion(); updateProgress(); } }

    function updateProgress(){
      const cur = state.cur+1, total = state.pool.length || 0;
      progressText.textContent = `${cur} / ${total}`;
      progressBar.style.width = total? `${(cur/total)*100}%` : '0%';
    }

    function showEmpty(){
      clearTimer();
      emptyMsg.classList.remove('hidden');
      card.classList.add('hidden');
      resultCard.classList.add('hidden');
      progressText.textContent = '0 / 0';
      progressBar.style.width = '0%';
    }

    // ====== N·ªôp b√†i ======
    function submitAll(){
      if(state.mode!=='exam') return;
      const total = state.pool.length;
      let correct = 0, wrongList = [];
      for(let i=0;i<total;i++){
        const q = state.pool[i];
        if(state.answers[i] === q.answer) correct++;
        else wrongList.push({s: state.subjectIdx, q: q._id});
      }
      // C·∫≠p nh·∫≠t wrong bank (gi·ªõi h·∫°n 200)
      state.wrongBank = (wrongList.concat(state.wrongBank)).slice(0,200);
      saveLS(LS_WRONG, state.wrongBank);

      clearTimer();
      scoreText.textContent = `ƒê√∫ng ${correct}/${total} c√¢u (${Math.round(correct*100/Math.max(1,total))}%).`;
      resultCard.classList.remove('hidden');

      btnReviewWrong.onclick = ()=>{
        // chuy·ªÉn sang luy·ªán t·∫≠p ch·ªâ c√°c c√¢u sai
        state.mode = 'practice';
        modeSelect.value = 'practice';
        state.filter = 'wrong';
        filterSelect.value = 'wrong';
        start();
      };
      btnRestart.onclick = start;
    }

    // ====== L∆∞·ªõi danh s√°ch c√¢u (bottom sheet) ======
    function buildGrid(){
      qGrid.innerHTML = '';
      const n = state.pool.length;
      for(let i=0;i<n;i++){
        const btn = document.createElement('button');
        btn.className = 'text-sm rounded-lg border border-slate-200 px-2 py-1 '+(i===state.cur?'bg-blue-600 text-white border-blue-600':'bg-white hover:bg-slate-50');
        btn.textContent = (i+1);
        btn.onclick = ()=>{ state.cur = i; renderQuestion(); updateProgress(); };
        qGrid.appendChild(btn);
      }
    }

    // ====== Timer (thi th·ª≠) ======
    function startTimer(){
      state.seconds = 0;
      timerLabel.textContent = '00:00';
      state.timer = setInterval(()=>{
        state.seconds++;
        const m = String(Math.floor(state.seconds/60)).padStart(2,'0');
        const s = String(state.seconds%60).padStart(2,'0');
        timerLabel.textContent = `${m}:${s}`;
      }, 1000);
    }
    function clearTimer(){
      if(state.timer){ clearInterval(state.timer); state.timer = null; }
    }

    // DOM ready
    document.addEventListener('DOMContentLoaded', init);
  })();
  </script>
</body>
</html>
